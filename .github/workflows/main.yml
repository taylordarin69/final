# FlashLoan Gas Sponsor — Full Repo (WETH → ETH reimburse support)

This canvas contains a complete, copy‑pasteable starter repository for a **FlashLoan Gas Sponsor** system. It now includes native‑ETH reimbursement support (WETH unwrap), an updated EIP‑712 flow, a single‑command local deploy script, and tests that cover the WETH → ETH reimbursement path.

---

## Repository overview (updated)

```
flashloan-gas-sponsor/
├─ contracts/
│  ├─ FlashLoanGasSponsor.sol        # supports reimburseInETH via WETH.unwrap
│  ├─ MockERC20.sol
│  ├─ MockPool.sol
│  ├─ DummyUserTarget.sol
│  └─ MockWETH.sol                   # WETH-like token for tests
├─ scripts/
│  ├─ deploy.js
│  └─ deploy_local.js                # single-command local deploy for testing
├─ test/
│  ├─ flashloan.test.js
│  └─ flashloan_weth.test.js         # tests reimburse in ETH via MockWETH
├─ relayer/
│  ├─ server.js                      # EIP-712 verification + reimburseInETH handling
│  ├─ index.js                       # updated ABI to include reimburseInETH boolean
│  └─ utils.js
├─ frontend/
│  ├─ package.json
│  └─ src/
│     ├─ main.jsx
│     ├─ App.jsx
│     ├─ SignIntent.jsx              # checkbox to choose reimburseInETH
│     └─ relayerClient.js
├─ tools/
│  └─ calcGas.js
├─ hardhat.config.js
├─ package.json
├─ README.md
└─ .env.example
```

---

# 1) Contracts — `FlashLoanGasSponsor.sol`

The contract now supports reimbursing the relayer either in the borrowed ERC‑20 token or in native ETH by unwrapping WETH. Safety checks ensure the contract retains enough WETH to repay the pool before performing any WETH → ETH unwrap.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address owner) external view returns (uint256);
}

interface IPool {
    function flashLoanSimple(
        address receiverAddress,
        address asset,
        uint256 amount,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface IFlashLoanReceiver {
    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address initiator,
        bytes calldata params
    ) external returns (bool);
}

interface IWETH {
    function withdraw(uint256 wad) external;
    function deposit() external payable;
    function transfer(address to, uint256 amount) external returns (bool);
}

contract FlashLoanGasSponsor is IFlashLoanReceiver {
    IPool public immutable pool;
    address public owner;

    event FlashLoanRequested(address asset, uint256 amount, address relayer);
    event Reimbursed(address relayer, uint256 amount, bool inETH);
    event UserCallExecuted(address target, bytes data, bool success);

    constructor(address _pool) {
        pool = IPool(_pool);
        owner = msg.sender;
    }

    // sponsorWithFlashLoan now accepts reimburseInETH boolean
    function sponsorWithFlashLoan(
        address asset,
        uint256 amount,
        address relayerAddress,
        address userTarget,
        bytes calldata userCallData,
        uint256 reimburseAmount,
        bool reimburseInETH
    ) external {
        require(relayerAddress != address(0), "invalid relayer");
        bytes memory params = abi.encode(relayerAddress, userTarget, userCallData, reimburseAmount, reimburseInETH);
        emit FlashLoanRequested(asset, amount, relayerAddress);
        pool.flashLoanSimple(address(this), asset, amount, params, 0);
    }

    // allow contract to receive ETH when WETH.withdraw is called
    receive() external payable {}

    function executeOperation(
        address asset,
        uint256 amount,
        uint256 premium,
        address,
        bytes calldata params
    ) external override returns (bool) {
        require(msg.sender == address(pool), "only pool");

        (address relayerAddress, address userTarget, bytes memory userCallData, uint256 reimburseAmount, bool reimburseInETH) =
            abi.decode(params, (address, address, bytes, uint256, bool));

        // 1) perform user action
        (bool success, ) = userTarget.call(userCallData);
        emit UserCallExecuted(userTarget, userCallData, success);
        require(success, "user call failed");

        uint256 totalOwed = amount + premium;

        // 2) reimburse relayer
        if (reimburseAmount > 0) {
            if (reimburseInETH) {
                // ensure asset is WETH-like and we have enough WETH to cover reimburse + totalOwed
                uint256 bal = IERC20(asset).balanceOf(address(this));
                require(bal >= reimburseAmount + totalOwed, "insufficient WETH for reimburse+repay");

                // withdraw reimburseAmount WETH to ETH and send to relayer
                IWETH(asset).withdraw(reimburseAmount);
                (bool sent, ) = payable(relayerAddress).call{ value: reimburseAmount }("");
                require(sent, "reimburse ETH send failed");
                emit Reimbursed(relayerAddress, reimburseAmount, true);
            } else {
                // pay in ERC20 asset
                IERC20(asset).transfer(relayerAddress, reimburseAmount);
                emit Reimbursed(relayerAddress, reimburseAmount, false);
            }
        }

        // 3) approve pool to pull repayment (amount + premium)
        IERC20(asset).approve(address(pool), totalOwed);

        return true;
    }

    // admin
    function setOwner(address _o) external {
        require(msg.sender == owner, "only owner");
        owner = _o;
    }
}
```

**Safety notes:**

* The contract ensures `IERC20(asset).balanceOf(address(this)) >= reimburseAmount + totalOwed` before unwrapping WETH to ETH. This preserves funds needed to repay the pool.
* Verify the pool’s expected repayment mechanism for production deployments.

---

# 2) Mock WETH token (`contracts/MockWETH.sol`)

A WETH-like ERC‑20 with `deposit`, `withdraw`, and a test `mint` helper.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockWETH is ERC20 {
    constructor() ERC20("Mock WETH", "mWETH") {}

    function deposit() external payable {
        _mint(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) external {
        require(balanceOf(msg.sender) >= wad, "insufficient balance");
        _burn(msg.sender, wad);
        payable(msg.sender).transfer(wad);
    }

    // convenience mint for tests
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}
```

---

# 3) WETH → ETH reimbursement test (`test/flashloan_weth.test.js`)

This test deploys `MockWETH`, `MockPool`, the sponsor contract, and a dummy user target. It checks that the `Reimbursed` event is emitted with `inETH == true` when `reimburseInETH` is set.

```js
const { expect } = require('chai');
const { ethers } = require('hardhat');

describe('FlashLoanGasSponsor WETH->ETH reimburse', function () {
  let deployer, relayer, user;
  let weth, pool, sponsor, dummy;

  beforeEach(async () => {
    [deployer, relayer, user] = await ethers.getSigners();

    const WETH = await ethers.getContractFactory('MockWETH');
    weth = await WETH.deploy();
    await weth.deployed();

    const MockPool = await ethers.getContractFactory('MockPool');
    pool = await MockPool.deploy(weth.address);
    await pool.deployed();

    const Sponsor = await ethers.getContractFactory('FlashLoanGasSponsor');
    sponsor = await Sponsor.deploy(pool.address);
    await sponsor.deployed();

    const Dummy = await ethers.getContractFactory('DummyUserTarget');
    dummy = await Dummy.deploy();
    await dummy.deployed();

    // fund pool with WETH by minting directly to pool
    await weth.mint(pool.address, ethers.utils.parseEther('1000'));

    // Also fund sponsor contract with a small amount of WETH so it has balance after loan if needed
    await weth.mint(sponsor.address, ethers.utils.parseEther('0.5'));
  });

  it('reimburses relayer in ETH via WETH.withdraw', async () => {
    const loanAmt = ethers.utils.parseEther('1');
    const reimburseAmt = ethers.utils.parseEther('0.01');

    const callData = dummy.interface.encodeFunctionData('doThing', [user.address]);

    // Relayer triggers sponsorWithFlashLoan with reimburseInETH = true
    const tx = await sponsor.connect(relayer).sponsorWithFlashLoan(weth.address, loanAmt, relayer.address, dummy.address, callData, reimburseAmt, true);
    const rcpt = await tx.wait();

    // Verify Reimbursed event
    const iface = new ethers.utils.Interface(["event Reimbursed(address indexed relayer, uint256 amount, bool inETH)"]);
    const logs = rcpt.logs.filter(l => l.address.toLowerCase() === sponsor.address.toLowerCase());
    const parsed = logs.map(l => {
      try { return iface.parseLog(l); } catch (e) { return null }
    }).filter(x=>x);

    expect(parsed.length).to.be.greaterThan(0);
    const reimbEvent = parsed.find(e => e.name === 'Reimbursed');
    expect(reimbEvent.args.relayer).to.equal(relayer.address);
    expect(reimbEvent.args.amount).to.equal(reimburseAmt);
    expect(reimbEvent.args.inETH).to.equal(true);
  });
});
```

**Note:** the test verifies the emitted event rather than raw ETH balances (to avoid gas noise caused by the relayer paying gas).

---

# 4) Relayer updates

Update the relayer ABI and submission flow to include the `reimburseInETH` boolean. Example ABI:

```js
const routerAbi = [
  'function sponsorWithFlashLoan(address asset,uint256 amount,address relayerAddress,address userTarget,bytes userCallData,uint256 reimburseAmount,bool reimburseInETH)'
];
```

When submitting, pass the `reimburseInETH` flag through to the contract call.

In `relayer/server.js` accept `intent.reimburseInETH` (default `false`) and forward it to `submitSponsoredTx`.

---

# 5) Frontend change — checkbox for ETH reimburse

Add a checkbox in `SignIntent.jsx` that lets the user choose whether to reimburse the relayer in native ETH (unwrap WETH). The signed EIP‑712 intent now includes the boolean `reimburseInETH`.

(See the updated `SignIntent.jsx` component in the repo for exact code.)

---

# 6) Relayer server handler snippet

Update the handler to read `intent.reimburseInETH` and include it in the transaction submission:

```js
const reimburseInETH = !!intent.reimburseInETH;

const receipt = await submitSponsoredTx({
  asset: intent.asset,
  amount: intent.amount,
  relayerAddress: process.env.RELAYER_ADDRESS,
  userTarget: intent.userTarget,
  userCallData: intent.userCallDataHex,
  reimburseAmount: reimburse.toString(),
  reimburseInETH
});
```

---

# 7) Running the WETH tests locally

1. Start Hardhat node: `npx hardhat node` (or fork mainnet).
2. Run the test: `npx hardhat test test/flashloan_weth.test.js --network localhost`.

Expected result: the test passes and the `Reimbursed` event is emitted with `inETH === true`.

---

# 8) Final recommendations

* Maintain precise accounting for principal, premium, and reimbursements. The WETH→ETH route must never reduce the contract balance below the repayment amount.
* Prefer ERC‑20 reimbursement where possible to avoid native transfer edge cases. Use ETH reimburse only when necessary and under strict caps.
* Add negative tests for over‑reimbursement, failed user calls, and WETH withdrawal failures.

---

If you’d like next steps, I can:

* paste the exact updated files into the canvas as individual code blocks so you can copy per file, or
* generate a ready‑to‑apply `git` patch you can run locally, or
* walk through executing the WETH reimbursement test step‑by‑step with expected console output.

Which would you prefer?
